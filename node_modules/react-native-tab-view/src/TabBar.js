/* @flow */

<<<<<<< HEAD
import React, { PureComponent } from 'react';
=======
import * as React from 'react';
>>>>>>> a622a84fa9b65a4b43e8645addefe35ee1624fe7
import PropTypes from 'prop-types';
import {
  Animated,
  StyleSheet,
  View,
<<<<<<< HEAD
  Text,
=======
>>>>>>> a622a84fa9b65a4b43e8645addefe35ee1624fe7
  ScrollView,
  Platform,
  I18nManager,
} from 'react-native';
import TouchableItem from './TouchableItem';
import { SceneRendererPropType } from './TabViewPropTypes';
import type {
  Scene,
  SceneRendererProps,
<<<<<<< HEAD
  Route,
=======
>>>>>>> a622a84fa9b65a4b43e8645addefe35ee1624fe7
  Style,
} from './TabViewTypeDefinitions';

type IndicatorProps<T> = SceneRendererProps<T> & {
<<<<<<< HEAD
  width: Animated.Value,
};

type ScrollEvent = {
  nativeEvent: {
    contentOffset: {
      x: number,
    },
  },
};

type DefaultProps<T> = {
  getLabelText: (scene: Scene<T>) => ?string,
=======
  width: number,
>>>>>>> a622a84fa9b65a4b43e8645addefe35ee1624fe7
};

type Props<T> = SceneRendererProps<T> & {
  scrollEnabled?: boolean,
  pressColor?: string,
  pressOpacity?: number,
  getLabelText: (scene: Scene<T>) => ?string,
  renderLabel?: (scene: Scene<T>) => ?React.Element<any>,
  renderIcon?: (scene: Scene<T>) => ?React.Element<any>,
  renderBadge?: (scene: Scene<T>) => ?React.Element<any>,
  renderIndicator?: (props: IndicatorProps<T>) => ?React.Element<any>,
  onTabPress?: (scene: Scene<T>) => void,
  tabStyle?: Style,
  indicatorStyle?: Style,
  labelStyle?: Style,
  style?: Style,
};

<<<<<<< HEAD
type State = {
  offset: Animated.Value,
  visibility: Animated.Value,
  initialOffset: { x: number, y: number },
};

export default class TabBar<T: Route<*>> extends PureComponent<
  DefaultProps<T>,
  Props<T>,
  State
> {
=======
type State = {|
  visibility: Animated.Value,
  scrollAmount: Animated.Value,
  initialOffset: ?{| x: number, y: number |},
|};

export default class TabBar<T: *> extends React.Component<Props<T>, State> {
>>>>>>> a622a84fa9b65a4b43e8645addefe35ee1624fe7
  static propTypes = {
    ...SceneRendererPropType,
    scrollEnabled: PropTypes.bool,
    pressColor: TouchableItem.propTypes.pressColor,
    pressOpacity: TouchableItem.propTypes.pressOpacity,
    getLabelText: PropTypes.func,
    renderIcon: PropTypes.func,
    renderLabel: PropTypes.func,
    renderIndicator: PropTypes.func,
    onTabPress: PropTypes.func,
<<<<<<< HEAD
    labelStyle: Text.propTypes.style,
=======
    labelStyle: PropTypes.any,
>>>>>>> a622a84fa9b65a4b43e8645addefe35ee1624fe7
    style: PropTypes.any,
  };

  static defaultProps = {
    getLabelText: ({ route }) =>
<<<<<<< HEAD
      route.title ? route.title.toUpperCase() : null,
=======
      typeof route.title === 'string' ? route.title.toUpperCase() : route.title,
>>>>>>> a622a84fa9b65a4b43e8645addefe35ee1624fe7
  };

  constructor(props: Props<T>) {
    super(props);

<<<<<<< HEAD
    let initialVisibility = 0;

    if (this.props.scrollEnabled === true) {
      const tabWidth = this._getTabWidthFromStyle(this.props.tabStyle);
      if (this.props.layout.width || tabWidth) {
        initialVisibility = 1;
      }
    } else {
      initialVisibility = 1;
    }

    this.state = {
      offset: new Animated.Value(0),
      visibility: new Animated.Value(initialVisibility),
      initialOffset: {
        x: this._getScrollAmount(this.props, this.props.navigationState.index),
        y: 0,
      },
    };
  }

  state: State;

  componentDidMount() {
    this._adjustScroll(this.props.navigationState.index);
    this._positionListener = this.props.subscribe(
      'position',
      this._adjustScroll
    );
  }

  componentWillReceiveProps(nextProps: Props<T>) {
    if (this.props.navigationState !== nextProps.navigationState) {
      this._resetScrollOffset(nextProps);
    }

    const nextTabWidth = this._getTabWidthFromStyle(nextProps.tabStyle);

    if (
      (this.props.tabStyle !== nextProps.tabStyle && nextTabWidth) ||
      (this.props.layout.width !== nextProps.layout.width &&
        nextProps.layout.width)
    ) {
      this.state.visibility.setValue(1);
    }
  }

  componentDidUpdate(prevProps: Props<T>) {
    if (
      this.props.scrollEnabled &&
      (prevProps.layout !== this.props.layout ||
        prevProps.tabStyle !== this.props.tabStyle)
    ) {
      global.requestAnimationFrame(() =>
        this._adjustScroll(this.props.navigationState.index)
      );
=======
    let initialVisibility = 1;

    if (this.props.scrollEnabled) {
      const tabWidth = this._getTabWidth(this.props);
      if (!tabWidth) {
        initialVisibility = 0;
      }
    }

    const initialOffset =
      this.props.scrollEnabled && this.props.layout.width
        ? {
            x: this._getScrollAmount(
              this.props,
              this.props.navigationState.index
            ),
            y: 0,
          }
        : undefined;

    this.state = {
      visibility: new Animated.Value(initialVisibility),
      scrollAmount: new Animated.Value(0),
      initialOffset,
    };
  }

  componentDidMount() {
    this._adjustScroll(this.props.navigationState.index);
    this.props.scrollEnabled && this._startTrackingPosition();
  }

  componentDidUpdate(prevProps: Props<T>) {
    const prevTabWidth = this._getTabWidth(prevProps);
    const currentTabWidth = this._getTabWidth(this.props);

    if (prevTabWidth !== currentTabWidth && currentTabWidth) {
      this.state.visibility.setValue(1);
    }

    if (
      (prevProps.navigationState !== this.props.navigationState ||
        prevProps.layout !== this.props.layout ||
        prevTabWidth !== currentTabWidth) &&
      this.props.navigationState.index !== this._pendingIndex
    ) {
      this._resetScroll(
        this.props.navigationState.index,
        Boolean(prevProps.layout.width)
      );
      this._pendingIndex = null;
>>>>>>> a622a84fa9b65a4b43e8645addefe35ee1624fe7
    }
  }

  componentWillUnmount() {
<<<<<<< HEAD
    this._positionListener.remove();
  }

  _positionListener: Object;
  _scrollView: Object;
  _isManualScroll: boolean = false;
  _isMomentumScroll: boolean = false;
=======
    this._stopTrackingPosition();
  }

  _scrollView: ?ScrollView;
  _isManualScroll: boolean = false;
  _isMomentumScroll: boolean = false;
  _pendingIndex: ?number;
  _scrollDelta: number = 0;
  _scrollResetCallback: any;
  _lastPanX: ?number;
  _lastOffsetX: ?number;
  _panXListener: string;
  _offsetXListener: string;

  _startTrackingPosition = () => {
    this._offsetXListener = this.props.offsetX.addListener(({ value }) => {
      this._lastOffsetX = value;
      this._handlePosition();
    });
    this._panXListener = this.props.panX.addListener(({ value }) => {
      this._lastPanX = value;
      this._handlePosition();
    });
  };

  _stopTrackingPosition = () => {
    this.props.offsetX.removeListener(this._offsetXListener);
    this.props.panX.removeListener(this._panXListener);
  };

  _handlePosition = () => {
    const { navigationState, layout } = this.props;
    const panX = typeof this._lastPanX === 'number' ? this._lastPanX : 0;
    const offsetX =
      typeof this._lastOffsetX === 'number'
        ? this._lastOffsetX
        : -navigationState.index * layout.width;

    const value = (panX + offsetX) / -(layout.width || 0.001);

    this._adjustScroll(value);
  };
>>>>>>> a622a84fa9b65a4b43e8645addefe35ee1624fe7

  _renderLabel = (scene: Scene<*>) => {
    if (typeof this.props.renderLabel !== 'undefined') {
      return this.props.renderLabel(scene);
    }
    const label = this.props.getLabelText(scene);
    if (typeof label !== 'string') {
      return null;
    }
    return (
<<<<<<< HEAD
      <Text style={[styles.tabLabel, this.props.labelStyle]}>
        {label}
      </Text>
=======
      <Animated.Text style={[styles.tabLabel, this.props.labelStyle]}>
        {label}
      </Animated.Text>
>>>>>>> a622a84fa9b65a4b43e8645addefe35ee1624fe7
    );
  };

  _renderIndicator = (props: IndicatorProps<T>) => {
    if (typeof this.props.renderIndicator !== 'undefined') {
      return this.props.renderIndicator(props);
    }
<<<<<<< HEAD
    const { width, position } = props;
    const translateX = Animated.multiply(
      Animated.multiply(position, width),
=======
    const { width, position, navigationState } = props;
    const translateX = Animated.multiply(
      Animated.multiply(
        position.interpolate({
          inputRange: [0, navigationState.routes.length - 1],
          outputRange: [0, navigationState.routes.length - 1],
          extrapolate: 'clamp',
        }),
        width
      ),
>>>>>>> a622a84fa9b65a4b43e8645addefe35ee1624fe7
      I18nManager.isRTL ? -1 : 1
    );
    return (
      <Animated.View
        style={[
          styles.indicator,
          { width, transform: [{ translateX }] },
          this.props.indicatorStyle,
        ]}
      />
    );
  };

<<<<<<< HEAD
  _tabWidthCache: ?{ style: any, width: ?number };

  _getTabWidthFromStyle = (style: any) => {
    if (this._tabWidthCache && this._tabWidthCache.style === style) {
      return this._tabWidthCache.width;
    }
    const passedTabStyle = StyleSheet.flatten(this.props.tabStyle);
    const cache = {
      style,
      width: passedTabStyle ? passedTabStyle.width : null,
    };
    this._tabWidthCache = cache;
    return cache;
  };

  _getFinalTabWidth = (props: Props<T>) => {
    const { layout, navigationState } = props;
    const tabWidth = this._getTabWidthFromStyle(props.tabStyle);
    if (typeof tabWidth === 'number') {
      return tabWidth;
    }
    if (typeof tabWidth === 'string' && tabWidth.endsWith('%')) {
      return layout.width * (parseFloat(tabWidth) / 100);
    }
    if (props.scrollEnabled) {
      return layout.width / 5 * 2;
    }
    return layout.width / navigationState.routes.length;
  };

  _getMaxScrollableDistance = (props: Props<T>) => {
    const { layout, navigationState } = props;
    if (layout.width === 0) {
      return 0;
    }
    const finalTabWidth = this._getFinalTabWidth(props);
    const tabBarWidth = finalTabWidth * navigationState.routes.length;
    const maxDistance = tabBarWidth - layout.width;
    return Math.max(maxDistance, 0);
  };

  _normalizeScrollValue = (props: Props<T>, value: number) => {
    const maxDistance = this._getMaxScrollableDistance(props);
    return Math.max(Math.min(value, maxDistance), 0);
  };

  _getScrollAmount = (props: Props<T>, i: number) => {
    const { layout } = props;
    const finalTabWidth = this._getFinalTabWidth(props);
    const centerDistance = finalTabWidth * i + finalTabWidth / 2;
    const scrollAmount = centerDistance - layout.width / 2;
    return this._normalizeScrollValue(props, scrollAmount);
  };

  _resetScrollOffset = (props: Props<T>) => {
    if (!props.scrollEnabled || !this._scrollView) {
      return;
    }

    const scrollAmount = this._getScrollAmount(
      props,
      props.navigationState.index
    );
    this._scrollView.scrollTo({
      x: scrollAmount,
      animated: true,
    });
    Animated.timing(this.state.offset, {
      toValue: 0,
      duration: 150,
    }).start();
  };

  _adjustScroll = (index: number) => {
    if (!this.props.scrollEnabled || !this._scrollView) {
      return;
    }

    const scrollAmount = this._getScrollAmount(this.props, index);
    this._scrollView.scrollTo({
      x: scrollAmount,
      animated: false,
    });
  };

  _adjustOffset = (value: number) => {
    if (!this._isManualScroll || !this.props.scrollEnabled) {
      return;
    }

    const scrollAmount = this._getScrollAmount(
      this.props,
      this.props.navigationState.index
    );
    const scrollOffset = value - scrollAmount;

    if (this._isMomentumScroll) {
      Animated.spring(this.state.offset, {
        toValue: -scrollOffset,
        tension: 300,
        friction: 35,
      }).start();
    } else {
      this.state.offset.setValue(-scrollOffset);
    }
  };

  _handleScroll = (e: ScrollEvent) => {
    this._adjustOffset(e.nativeEvent.contentOffset.x);
=======
  _getTabWidth = props => {
    const { layout, navigationState, tabStyle } = props;
    const flattened = StyleSheet.flatten(tabStyle);

    if (flattened) {
      switch (typeof flattened.width) {
        case 'number':
          return flattened.width;
        case 'string':
          if (flattened.width.endsWith('%')) {
            const width = parseFloat(flattened.width);
            if (Number.isFinite(width)) {
              return layout.width * (width / 100);
            }
          }
      }
    }

    if (props.scrollEnabled) {
      return layout.width / 5 * 2;
    }

    return layout.width / navigationState.routes.length;
  };

  _handleTabPress = (scene: Scene<*>) => {
    this._pendingIndex = scene.index;
    this.props.jumpToIndex(scene.index);
    if (this.props.onTabPress) {
      this.props.onTabPress(scene);
    }
  };

  _handleScroll = event => {
    if (this._isManualScroll) {
      this._scrollDelta =
        this._getScrollAmount(this.props, this.props.navigationState.index) -
        event.nativeEvent.contentOffset.x;
    }
  };

  _normalizeScrollValue = (props, value) => {
    const { layout, navigationState } = props;
    const tabWidth = this._getTabWidth(props);
    const tabBarWidth = Math.max(
      tabWidth * navigationState.routes.length,
      layout.width
    );
    const maxDistance = tabBarWidth - layout.width;

    return Math.max(Math.min(value, maxDistance), 0);
  };

  _getScrollAmount = (props, i) => {
    const { layout } = props;
    const tabWidth = this._getTabWidth(props);
    const centerDistance = tabWidth * (i + 1 / 2);
    const scrollAmount = centerDistance - layout.width / 2;

    return this._normalizeScrollValue(props, scrollAmount);
  };

  _adjustScroll = (value: number) => {
    if (this.props.scrollEnabled) {
      global.cancelAnimationFrame(this._scrollResetCallback);
      this._scrollView &&
        this._scrollView.scrollTo({
          x: this._normalizeScrollValue(
            this.props,
            this._getScrollAmount(this.props, value) - this._scrollDelta
          ),
          animated: false,
        });
    }
  };

  _resetScroll = (value: number, animated = true) => {
    if (this.props.scrollEnabled) {
      global.cancelAnimationFrame(this._scrollResetCallback);
      this._scrollResetCallback = global.requestAnimationFrame(() => {
        this._scrollDelta = 0;
        this._scrollView &&
          this._scrollView.scrollTo({
            x: this._getScrollAmount(this.props, value),
            animated,
          });
      });
    }
>>>>>>> a622a84fa9b65a4b43e8645addefe35ee1624fe7
  };

  _handleBeginDrag = () => {
    // onScrollBeginDrag fires when user touches the ScrollView
    this._isManualScroll = true;
    this._isMomentumScroll = false;
  };

  _handleEndDrag = () => {
    // onScrollEndDrag fires when user lifts his finger
    // onMomentumScrollBegin fires after touch end
    // run the logic in next frame so we get onMomentumScrollBegin first
    global.requestAnimationFrame(() => {
      if (this._isMomentumScroll) {
        return;
      }
      this._isManualScroll = false;
    });
  };

  _handleMomentumScrollBegin = () => {
    // onMomentumScrollBegin fires on flick, as well as programmatic scroll
    this._isMomentumScroll = true;
  };

  _handleMomentumScrollEnd = () => {
    // onMomentumScrollEnd fires when the scroll finishes
    this._isMomentumScroll = false;
    this._isManualScroll = false;
  };

<<<<<<< HEAD
  _setRef = (el: Object) => (this._scrollView = el);
=======
  _setRef = (el: ?Animated.ScrollView) =>
    (this._scrollView = el && el._component);
>>>>>>> a622a84fa9b65a4b43e8645addefe35ee1624fe7

  render() {
    const { position, navigationState, scrollEnabled } = this.props;
    const { routes, index } = navigationState;
<<<<<<< HEAD
    const maxDistance = this._getMaxScrollableDistance(this.props);
    const finalTabWidth = this._getFinalTabWidth(this.props);
    const tabBarWidth = finalTabWidth * routes.length;

    // Prepend '-1', so there are always at least 2 items in inputRange
    const inputRange = [-1, ...routes.map((x, i) => i)];
    const translateOutputRange = inputRange.map(
      i => this._getScrollAmount(this.props, i) * -1
    );

    const translateX = Animated.add(
      position.interpolate({
        inputRange,
        outputRange: translateOutputRange,
      }),
      this.state.offset
    ).interpolate({
      inputRange: [-maxDistance, 0],
      outputRange: [-maxDistance, 0],
      extrapolate: 'clamp',
    });
=======
    const tabWidth = this._getTabWidth(this.props);
    const tabBarWidth = tabWidth * routes.length;

    // Prepend '-1', so there are always at least 2 items in inputRange
    const inputRange = [-1, ...routes.map((x, i) => i)];
    const translateX = Animated.multiply(this.state.scrollAmount, -1);
>>>>>>> a622a84fa9b65a4b43e8645addefe35ee1624fe7

    return (
      <Animated.View style={[styles.tabBar, this.props.style]}>
        <Animated.View
          pointerEvents="none"
          style={[
            styles.indicatorContainer,
            scrollEnabled
              ? { width: tabBarWidth, transform: [{ translateX }] }
              : null,
          ]}
        >
          {this._renderIndicator({
            ...this.props,
<<<<<<< HEAD
            width: new Animated.Value(finalTabWidth),
          })}
        </Animated.View>
        <View style={styles.scroll}>
          <ScrollView
            horizontal
=======
            width: tabWidth,
          })}
        </Animated.View>
        <View style={styles.scroll}>
          <Animated.ScrollView
            horizontal
            keyboardShouldPersistTaps="handled"
>>>>>>> a622a84fa9b65a4b43e8645addefe35ee1624fe7
            scrollEnabled={scrollEnabled}
            bounces={false}
            alwaysBounceHorizontal={false}
            scrollsToTop={false}
            showsHorizontalScrollIndicator={false}
            automaticallyAdjustContentInsets={false}
            overScrollMode="never"
            contentContainerStyle={[
              styles.tabContent,
              scrollEnabled ? null : styles.container,
            ]}
<<<<<<< HEAD
            scrollEventThrottle={16}
            onScroll={this._handleScroll}
=======
            scrollEventThrottle={1}
            onScroll={Animated.event(
              [
                {
                  nativeEvent: {
                    contentOffset: { x: this.state.scrollAmount },
                  },
                },
              ],
              { useNativeDriver: true, listener: this._handleScroll }
            )}
>>>>>>> a622a84fa9b65a4b43e8645addefe35ee1624fe7
            onScrollBeginDrag={this._handleBeginDrag}
            onScrollEndDrag={this._handleEndDrag}
            onMomentumScrollBegin={this._handleMomentumScrollBegin}
            onMomentumScrollEnd={this._handleMomentumScrollEnd}
            contentOffset={this.state.initialOffset}
            ref={this._setRef}
          >
            {routes.map((route, i) => {
              const focused = index === i;
              const outputRange = inputRange.map(
                inputIndex => (inputIndex === i ? 1 : 0.7)
              );
              const opacity = Animated.multiply(
                this.state.visibility,
                position.interpolate({
                  inputRange,
                  outputRange,
                })
              );
              const scene = {
                route,
                focused,
                index: i,
              };
              const label = this._renderLabel(scene);
              const icon = this.props.renderIcon
                ? this.props.renderIcon(scene)
                : null;
              const badge = this.props.renderBadge
                ? this.props.renderBadge(scene)
                : null;

              const tabStyle = {};

              tabStyle.opacity = opacity;

              if (icon) {
                if (label) {
                  tabStyle.paddingTop = 8;
                } else {
                  tabStyle.padding = 12;
                }
              }

              const passedTabStyle = StyleSheet.flatten(this.props.tabStyle);
              const isWidthSet =
                (passedTabStyle &&
                  typeof passedTabStyle.width !== 'undefined') ||
                scrollEnabled === true;
              const tabContainerStyle = {};

              if (isWidthSet) {
<<<<<<< HEAD
                tabStyle.width = finalTabWidth;
=======
                tabStyle.width = tabWidth;
>>>>>>> a622a84fa9b65a4b43e8645addefe35ee1624fe7
              }

              if (passedTabStyle && typeof passedTabStyle.flex === 'number') {
                tabContainerStyle.flex = passedTabStyle.flex;
              } else if (!isWidthSet) {
                tabContainerStyle.flex = 1;
              }

              const accessibilityLabel =
                route.accessibilityLabel || route.title;

              return (
                <TouchableItem
                  borderless
                  key={route.key}
                  testID={route.testID}
                  accessible={route.accessible}
                  accessibilityLabel={accessibilityLabel}
                  accessibilityTraits="button"
                  pressColor={this.props.pressColor}
                  pressOpacity={this.props.pressOpacity}
                  delayPressIn={0}
<<<<<<< HEAD
                  onPress={() => {
                    // eslint-disable-line react/jsx-no-bind
                    const { onTabPress, jumpToIndex } = this.props;
                    jumpToIndex(i);
                    if (onTabPress) {
                      onTabPress(scene);
                    }
                  }}
                  style={tabContainerStyle}
                >
                  <View style={styles.container}>
=======
                  onPress={() => this._handleTabPress(scene)}
                  style={tabContainerStyle}
                >
                  <View pointerEvents="none" style={styles.container}>
>>>>>>> a622a84fa9b65a4b43e8645addefe35ee1624fe7
                    <Animated.View
                      style={[
                        styles.tabItem,
                        tabStyle,
                        passedTabStyle,
                        styles.container,
                      ]}
                    >
                      {icon}
                      {label}
                    </Animated.View>
<<<<<<< HEAD
                    {badge
                      ? <Animated.View
                          style={[
                            styles.badge,
                            { opacity: this.state.visibility },
                          ]}
                        >
                          {badge}
                        </Animated.View>
                      : null}
=======
                    {badge ? (
                      <Animated.View
                        style={[
                          styles.badge,
                          { opacity: this.state.visibility },
                        ]}
                      >
                        {badge}
                      </Animated.View>
                    ) : null}
>>>>>>> a622a84fa9b65a4b43e8645addefe35ee1624fe7
                  </View>
                </TouchableItem>
              );
            })}
<<<<<<< HEAD
          </ScrollView>
=======
          </Animated.ScrollView>
>>>>>>> a622a84fa9b65a4b43e8645addefe35ee1624fe7
        </View>
      </Animated.View>
    );
  }
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  scroll: {
    overflow: Platform.OS === 'web' ? 'auto' : 'scroll',
  },
  tabBar: {
    backgroundColor: '#2196f3',
    elevation: 4,
    shadowColor: 'black',
    shadowOpacity: 0.1,
    shadowRadius: StyleSheet.hairlineWidth,
    shadowOffset: {
      height: StyleSheet.hairlineWidth,
    },
    // We don't need zIndex on Android, disable it since it's buggy
    zIndex: Platform.OS === 'android' ? 0 : 1,
  },
  tabContent: {
    flexDirection: 'row',
    flexWrap: 'nowrap',
  },
  tabLabel: {
    backgroundColor: 'transparent',
    color: 'white',
    margin: 8,
  },
  tabItem: {
<<<<<<< HEAD
    flexGrow: 1,
=======
    flex: 1,
>>>>>>> a622a84fa9b65a4b43e8645addefe35ee1624fe7
    padding: 8,
    alignItems: 'center',
    justifyContent: 'center',
  },
  badge: {
    position: 'absolute',
    top: 0,
    right: 0,
  },
  indicatorContainer: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
  },
  indicator: {
    backgroundColor: '#ffeb3b',
    position: 'absolute',
    left: 0,
    bottom: 0,
    right: 0,
    height: 2,
  },
});
