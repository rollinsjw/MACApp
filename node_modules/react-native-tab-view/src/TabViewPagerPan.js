/* @flow */

<<<<<<< HEAD
import React, { PureComponent, Children } from 'react';
=======
import * as React from 'react';
>>>>>>> a622a84fa9b65a4b43e8645addefe35ee1624fe7
import PropTypes from 'prop-types';
import {
  Animated,
  PanResponder,
<<<<<<< HEAD
  Platform,
  StyleSheet,
  View,
  I18nManager,
} from 'react-native';
import { SceneRendererPropType } from './TabViewPropTypes';
import type {
  SceneRendererProps,
  Route,
=======
  StyleSheet,
  View,
  Platform,
} from 'react-native';
import { PagerRendererPropType } from './TabViewPropTypes';
import type {
  PagerRendererProps,
>>>>>>> a622a84fa9b65a4b43e8645addefe35ee1624fe7
  TransitionConfigurator,
} from './TabViewTypeDefinitions';

type GestureEvent = {
  nativeEvent: {
    changedTouches: Array<*>,
    identifier: number,
    locationX: number,
    locationY: number,
    pageX: number,
    pageY: number,
    target: number,
    timestamp: number,
    touches: Array<*>,
  },
};

type GestureState = {
  stateID: number,
  moveX: number,
  moveY: number,
  x0: number,
  y0: number,
  dx: number,
  dy: number,
  vx: number,
  vy: number,
  numberActiveTouches: number,
};

type GestureHandler = (event: GestureEvent, state: GestureState) => void;

<<<<<<< HEAD
type DefaultProps = {
  configureTransition: TransitionConfigurator,
  swipeDistanceThreshold: number,
  swipeVelocityThreshold: number,
};

type Props<T> = SceneRendererProps<T> & {
  configureTransition: TransitionConfigurator,
  animationEnabled?: boolean,
  swipeEnabled?: boolean,
  swipeDistanceThreshold: number,
  swipeVelocityThreshold: number,
  onSwipeStart?: GestureHandler,
  onSwipeEnd?: GestureHandler,
  children?: React.Element<any>,
=======
type Props<T> = PagerRendererProps<T> & {
  configureTransition?: TransitionConfigurator,
  swipeDistanceThreshold?: number,
  swipeVelocityThreshold?: number,
  onSwipeStart?: GestureHandler,
  onSwipeEnd?: GestureHandler,
>>>>>>> a622a84fa9b65a4b43e8645addefe35ee1624fe7
};

const DEAD_ZONE = 12;

const DefaultTransitionSpec = {
  timing: Animated.spring,
  tension: 300,
  friction: 35,
};

<<<<<<< HEAD
export default class TabViewPagerPan<T: Route<*>> extends PureComponent<
  DefaultProps,
  Props<T>,
  void
> {
  static propTypes = {
    ...SceneRendererPropType,
    configureTransition: PropTypes.func.isRequired,
    animationEnabled: PropTypes.bool,
    swipeEnabled: PropTypes.bool,
    swipeDistanceThreshold: PropTypes.number.isRequired,
    swipeVelocityThreshold: PropTypes.number.isRequired,
    onSwipeStart: PropTypes.func,
    onSwipeEnd: PropTypes.func,
    children: PropTypes.node,
  };

  static defaultProps = {
=======
export default class TabViewPagerPan<T: *> extends React.Component<Props<T>> {
  static propTypes = {
    ...PagerRendererPropType,
    configureTransition: PropTypes.func.isRequired,
    swipeDistanceThreshold: PropTypes.number,
    swipeVelocityThreshold: PropTypes.number,
    onSwipeStart: PropTypes.func,
    onSwipeEnd: PropTypes.func,
  };

  static defaultProps = {
    canJumpToTab: () => true,
>>>>>>> a622a84fa9b65a4b43e8645addefe35ee1624fe7
    configureTransition: () => DefaultTransitionSpec,
    initialLayout: {
      height: 0,
      width: 0,
    },
<<<<<<< HEAD
    swipeDistanceThreshold: 120,
    swipeVelocityThreshold: 0.25,
=======
>>>>>>> a622a84fa9b65a4b43e8645addefe35ee1624fe7
  };

  componentWillMount() {
    this._panResponder = PanResponder.create({
      onMoveShouldSetPanResponder: this._canMoveScreen,
      onMoveShouldSetPanResponderCapture: this._canMoveScreen,
      onPanResponderGrant: this._startGesture,
      onPanResponderMove: this._respondToGesture,
      onPanResponderTerminate: this._finishGesture,
      onPanResponderRelease: this._finishGesture,
      onPanResponderTerminationRequest: () => true,
    });
  }

<<<<<<< HEAD
  componentDidMount() {
    this._resetListener = this.props.subscribe('reset', this._transitionTo);
  }

=======
>>>>>>> a622a84fa9b65a4b43e8645addefe35ee1624fe7
  componentDidUpdate(prevProps: Props<T>) {
    if (prevProps.navigationState.index !== this.props.navigationState.index) {
      this._transitionTo(this.props.navigationState.index);
    }
  }

<<<<<<< HEAD
  componentWillUnmount() {
    this._resetListener.remove();
  }

  _panResponder: Object;
  _resetListener: Object;
  _pendingIndex = null;
  _lastValue = null;
  _isMoving = null;
  _startDirection = 0;

  _isIndexInRange = (index: number) => {
    const { routes } = this.props.navigationState;
    return index >= 0 && index <= routes.length - 1;
  };

  _isMovingHorizontally = (evt: GestureEvent, gestureState: GestureState) => {
    return (
      Math.abs(gestureState.dx) > Math.abs(gestureState.dy * 3) &&
      Math.abs(gestureState.vx) > Math.abs(gestureState.vy * 3)
    );
  };

  _isReverseDirection = (gestureState: GestureState) => {
    if (this._startDirection > 0) {
      return gestureState.vx < 0;
    } else {
      return gestureState.vx > 0;
    }
  };

  _getNextIndex = (evt: GestureEvent, gestureState: GestureState) => {
    const currentIndex =
      typeof this._pendingIndex === 'number'
        ? this._pendingIndex
        : this.props.navigationState.index;

    let swipeVelocityThreshold = this.props.swipeVelocityThreshold;

    if (Platform.OS === 'android') {
      // on Android, velocity is way lower due to timestamp being in nanosecond
      // normalize it to have the same velocity on both iOS and Android
      swipeVelocityThreshold /= 1000000;
    }

    if (
      Math.abs(gestureState.dx) > this.props.swipeDistanceThreshold ||
      Math.abs(gestureState.vx) > swipeVelocityThreshold
    ) {
      const nextIndex =
        currentIndex -
        gestureState.dx /
          Math.abs(gestureState.dx) *
          (I18nManager.isRTL ? -1 : 1);
      if (this._isIndexInRange(nextIndex)) {
        return nextIndex;
      }
    }
    return currentIndex;
  };

=======
  _isMovingHorizontally = (evt: GestureEvent, gestureState: GestureState) => {
    return (
      Math.abs(gestureState.dx) > Math.abs(gestureState.dy * 2) &&
      Math.abs(gestureState.vx) > Math.abs(gestureState.vy * 2)
    );
  };

>>>>>>> a622a84fa9b65a4b43e8645addefe35ee1624fe7
  _canMoveScreen = (evt: GestureEvent, gestureState: GestureState) => {
    if (this.props.swipeEnabled === false) {
      return false;
    }
<<<<<<< HEAD
    const { navigationState: { routes, index } } = this.props;
    const canMove =
      this._isMovingHorizontally(evt, gestureState) &&
      ((gestureState.dx >= DEAD_ZONE && index >= 0) ||
        (gestureState.dx <= -DEAD_ZONE && index <= routes.length - 1));
    if (canMove) {
      this._startDirection = gestureState.dx;
    }
    return canMove;
=======

    const { navigationState: { routes, index } } = this.props;

    return (
      this._isMovingHorizontally(evt, gestureState) &&
      ((gestureState.dx >= DEAD_ZONE && index >= 0) ||
        (gestureState.dx <= -DEAD_ZONE && index <= routes.length - 1))
    );
>>>>>>> a622a84fa9b65a4b43e8645addefe35ee1624fe7
  };

  _startGesture = (evt: GestureEvent, gestureState: GestureState) => {
    if (typeof this.props.onSwipeStart === 'function') {
      this.props.onSwipeStart(evt, gestureState);
    }
<<<<<<< HEAD
    this._lastValue = this.props.getLastPosition();
    this.props.position.stopAnimation();
  };

  _respondToGesture = (evt: GestureEvent, gestureState: GestureState) => {
    const { layout: { width } } = this.props;
    const currentPosition =
      typeof this._lastValue === 'number'
        ? this._lastValue
        : this.props.navigationState.index;
    const nextPosition =
      currentPosition - gestureState.dx / width * (I18nManager.isRTL ? -1 : 1);
    if (this._isMoving === null) {
      this._isMoving = this._isMovingHorizontally(evt, gestureState);
    }
    if (this._isMoving && this._isIndexInRange(nextPosition)) {
      this.props.position.setValue(nextPosition);
    }
  };

  _finishGesture = (evt: GestureEvent, gestureState: GestureState) => {
    if (typeof this.props.onSwipeEnd === 'function') {
      this.props.onSwipeEnd(evt, gestureState);
    }
    const currentIndex = this.props.navigationState.index;
    const currentValue = this.props.getLastPosition();
    if (currentValue !== currentIndex) {
      if (this._isMoving && !this._isReverseDirection(gestureState)) {
        const nextIndex = this._getNextIndex(evt, gestureState);
        this._transitionTo(nextIndex);
      } else {
        this._transitionTo(currentIndex);
      }
    }
    this._lastValue = null;
    this._isMoving = null;
  };

  _transitionTo = (toValue: number) => {
    const lastPosition = this.props.getLastPosition();
    const currentTransitionProps = {
      progress: lastPosition,
    };
    const nextTransitionProps = {
      progress: toValue,
    };

    this._pendingIndex = toValue;

    if (this.props.animationEnabled !== false) {
      const transitionSpec = this.props.configureTransition(
        currentTransitionProps,
        nextTransitionProps
      );
      const { timing, ...transitionConfig } = transitionSpec;

      timing(this.props.position, {
        ...transitionConfig,
        toValue,
      }).start(({ finished }) => {
        if (finished) {
          this.props.jumpToIndex(toValue);
          this._pendingIndex = null;
        }
      });
    } else {
      this.props.position.setValue(toValue);
      this.props.jumpToIndex(toValue);
      this._pendingIndex = null;
    }
  };

  render() {
    const { layout, position, navigationState, children } = this.props;
    const { width } = layout;
    const { routes } = navigationState;

    // Prepend '-1', so there are always at least 2 items in inputRange
    const inputRange = [-1, ...routes.map((x, i) => i)];
    const outputRange = inputRange.map(
      i => width * i * (I18nManager.isRTL ? 1 : -1)
    );

    const translateX = position.interpolate({
      inputRange,
      outputRange,
=======

    this.props.panX.stopAnimation();
  };

  _respondToGesture = (evt: GestureEvent, gestureState: GestureState) => {
    const { navigationState: { routes, index } } = this.props;

    if (
      // swiping left
      (gestureState.dx > 0 && index <= 0) ||
      // swiping right
      (gestureState.dx < 0 && index >= routes.length - 1)
    ) {
      return;
    }

    this.props.panX.setValue(gestureState.dx);
  };

  _finishGesture = (evt: GestureEvent, gestureState: GestureState) => {
    const {
      navigationState,
      layout,
      swipeDistanceThreshold = layout.width / 1.75,
    } = this.props;

    let { swipeVelocityThreshold = 0.15 } = this.props;

    if (Platform.OS === 'android') {
      // on Android, velocity is way lower due to timestamp being in nanosecond
      // normalize it to have the same velocity on both iOS and Android
      swipeVelocityThreshold /= 1000000;
    }

    const currentIndex =
      typeof this._pendingIndex === 'number'
        ? this._pendingIndex
        : navigationState.index;

    let nextIndex = currentIndex;

    if (
      Math.abs(gestureState.dx) > Math.abs(gestureState.dy) &&
      Math.abs(gestureState.vx) > Math.abs(gestureState.vy) &&
      (Math.abs(gestureState.dx) > swipeDistanceThreshold ||
        Math.abs(gestureState.vx) > swipeVelocityThreshold)
    ) {
      nextIndex = Math.round(
        Math.min(
          Math.max(
            0,
            currentIndex - gestureState.dx / Math.abs(gestureState.dx)
          ),
          navigationState.routes.length - 1
        )
      );
    }

    if (
      !isFinite(nextIndex) ||
      !this.props.canJumpToTab(this.props.navigationState.routes[nextIndex])
    ) {
      nextIndex = currentIndex;
    }

    this._transitionTo(nextIndex);
  };

  _transitionTo = (index: number) => {
    const offset = -index * this.props.layout.width;

    if (this.props.animationEnabled === false) {
      this.props.panX.setValue(0);
      this.props.offsetX.setValue(offset);
      return;
    }

    const { timing, ...transitionConfig } = DefaultTransitionSpec;

    Animated.parallel([
      timing(this.props.panX, {
        ...transitionConfig,
        toValue: 0,
      }),
      timing(this.props.offsetX, {
        ...transitionConfig,
        toValue: offset,
      }),
    ]).start(({ finished }) => {
      if (finished) {
        this.props.jumpToIndex(index);
        this._pendingIndex = null;
      }
    });

    this._pendingIndex = index;
  };

  _panResponder: any;
  _pendingIndex: ?number;

  render() {
    const { panX, offsetX, navigationState, layout, children } = this.props;
    const { width } = layout;
    const { routes } = navigationState;
    const maxTranslate = width * (routes.length - 1);
    const translateX = Animated.add(panX, offsetX).interpolate({
      inputRange: [-maxTranslate, 0],
      outputRange: [-maxTranslate, 0],
      extrapolate: 'clamp',
>>>>>>> a622a84fa9b65a4b43e8645addefe35ee1624fe7
    });

    return (
      <Animated.View
        style={[
          styles.sheet,
          width
<<<<<<< HEAD
            ? { width: routes.length * width, transform: [{ translateX }] }
=======
            ? {
                width: routes.length * width,
                transform: [{ translateX }],
              }
>>>>>>> a622a84fa9b65a4b43e8645addefe35ee1624fe7
            : null,
        ]}
        {...this._panResponder.panHandlers}
      >
<<<<<<< HEAD
        {Children.map(children, (child, i) =>
=======
        {React.Children.map(children, (child, i) => (
>>>>>>> a622a84fa9b65a4b43e8645addefe35ee1624fe7
          <View
            key={navigationState.routes[i].key}
            testID={navigationState.routes[i].testID}
            style={
              width
                ? { width }
                : i === navigationState.index ? StyleSheet.absoluteFill : null
            }
          >
            {i === navigationState.index || width ? child : null}
          </View>
<<<<<<< HEAD
        )}
=======
        ))}
>>>>>>> a622a84fa9b65a4b43e8645addefe35ee1624fe7
      </Animated.View>
    );
  }
}

const styles = StyleSheet.create({
  sheet: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'stretch',
  },
});
