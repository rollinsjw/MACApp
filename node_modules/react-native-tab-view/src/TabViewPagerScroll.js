/* @flow */

<<<<<<< HEAD
import React, { PureComponent, Children } from 'react';
import PropTypes from 'prop-types';
import { Platform, View, ScrollView, StyleSheet } from 'react-native';
import { SceneRendererPropType } from './TabViewPropTypes';
import type { SceneRendererProps, Route } from './TabViewTypeDefinitions';
=======
import * as React from 'react';
import { View, ScrollView, StyleSheet } from 'react-native';
import { PagerRendererPropType } from './TabViewPropTypes';
import type { PagerRendererProps } from './TabViewTypeDefinitions';
>>>>>>> a622a84fa9b65a4b43e8645addefe35ee1624fe7

type ScrollEvent = {
  nativeEvent: {
    contentOffset: {
      x: number,
      y: number,
    },
  },
};

<<<<<<< HEAD
type State = {
  initialOffset: { x: number, y: number },
};

type Props<T> = SceneRendererProps<T> & {
  animationEnabled?: boolean,
  swipeEnabled?: boolean,
  children?: React.Element<any>,
};

export default class TabViewPagerScroll<T: Route<*>> extends PureComponent<
  void,
  Props<T>,
  State
> {
  static propTypes = {
    ...SceneRendererPropType,
    animationEnabled: PropTypes.bool,
    swipeEnabled: PropTypes.bool,
    children: PropTypes.node,
=======
type State = {|
  initialOffset: {| x: number, y: number |},
|};

type Props<T> = PagerRendererProps<T>;

export default class TabViewPagerScroll<T: *> extends React.Component<
  Props<T>,
  State
> {
  static propTypes = PagerRendererPropType;

  static defaultProps = {
    canJumpToTab: () => true,
>>>>>>> a622a84fa9b65a4b43e8645addefe35ee1624fe7
  };

  constructor(props: Props<T>) {
    super(props);
<<<<<<< HEAD
    this.state = {
      initialOffset: {
        x: this.props.navigationState.index * this.props.layout.width,
=======

    const { navigationState, layout } = this.props;

    this.state = {
      initialOffset: {
        x: navigationState.index * layout.width,
>>>>>>> a622a84fa9b65a4b43e8645addefe35ee1624fe7
        y: 0,
      },
    };
  }

<<<<<<< HEAD
  state: State;

  componentDidMount() {
    this._scrollTo(
      this.props.navigationState.index * this.props.layout.width,
      false
    );
    this._resetListener = this.props.subscribe('reset', this._scrollTo);
  }

  componentDidUpdate(prevProps: Props<T>) {
    const amount = this.props.navigationState.index * this.props.layout.width;
    if (
      prevProps.navigationState !== this.props.navigationState ||
      prevProps.layout !== this.props.layout
    ) {
      if (
        Platform.OS === 'android' ||
        prevProps.navigationState !== this.props.navigationState
      ) {
        global.requestAnimationFrame(() => this._scrollTo(amount));
      } else {
        this._scrollTo(amount, false);
      }
    }
  }

  componentWillUnmount() {
    this._resetListener.remove();
  }

  _resetListener: Object;
  _scrollView: Object;
  _nextOffset = 0;
  _isIdle: boolean = true;

  _scrollTo = (x: number, animated = this.props.animationEnabled !== false) => {
    this._nextOffset = x;

    if (this._isIdle && this._scrollView) {
      this._scrollView.scrollTo({
        x,
        animated,
=======
  componentDidMount() {
    this._setInitialPage();
  }

  componentDidUpdate(prevProps: Props<T>) {
    if (
      prevProps.layout.width !== this.props.layout.width ||
      prevProps.navigationState !== this.props.navigationState
    ) {
      this._scrollTo(
        this.props.navigationState.index * this.props.layout.width,
        prevProps.layout.width === this.props.layout.width
      );
    }
  }

  _scrollView: ?ScrollView;
  _idleCallback: any;
  _isIdle: boolean = true;
  _isInitial: boolean = true;

  _setInitialPage = () => {
    if (this.props.layout.width) {
      this._isInitial = true;
      this._scrollTo(
        this.props.navigationState.index * this.props.layout.width,
        false
      );
    }

    setTimeout(() => {
      this._isInitial = false;
    }, 50);
  };

  _scrollTo = (x: number, animated) => {
    if (this._isIdle && this._scrollView) {
      this._scrollView.scrollTo({
        x,
        animated: animated && this.props.animationEnabled !== false,
>>>>>>> a622a84fa9b65a4b43e8645addefe35ee1624fe7
      });
    }
  };

  _handleMomentumScrollEnd = (e: ScrollEvent) => {
<<<<<<< HEAD
    const nextIndex = Math.round(
      e.nativeEvent.contentOffset.x / this.props.layout.width
    );
    this._isIdle = true;
    this.props.jumpToIndex(nextIndex);
  };

  _handleScroll = (e: ScrollEvent) => {
    this._isIdle =
      Math.abs(e.nativeEvent.contentOffset.x - this._nextOffset) < 0.1;
    this.props.position.setValue(
      e.nativeEvent.contentOffset.x / this.props.layout.width
    );
  };

  _setRef = (el: Object) => (this._scrollView = el);
=======
    let nextIndex = Math.round(
      e.nativeEvent.contentOffset.x / this.props.layout.width
    );

    if (this.props.canJumpToTab(this.props.navigationState.routes[nextIndex])) {
      this.props.jumpToIndex(nextIndex);
    } else {
      global.requestAnimationFrame(() => {
        this._scrollTo(
          this.props.navigationState.index * this.props.layout.width
        );
      });
    }
  };

  _handleScroll = (e: ScrollEvent) => {
    if (this._isInitial) {
      return;
    }

    const { navigationState, layout } = this.props;
    const offset = navigationState.index * layout.width;

    this.props.offsetX.setValue(-offset);
    this.props.panX.setValue(offset - e.nativeEvent.contentOffset.x);

    global.cancelAnimationFrame(this._idleCallback);

    this._isIdle = false;
    this._idleCallback = global.requestAnimationFrame(() => {
      this._isIdle = true;
    });
  };
>>>>>>> a622a84fa9b65a4b43e8645addefe35ee1624fe7

  render() {
    const { children, layout, navigationState } = this.props;
    return (
      <ScrollView
        horizontal
        pagingEnabled
        directionalLockEnabled
        keyboardDismissMode="on-drag"
        keyboardShouldPersistTaps="always"
<<<<<<< HEAD
=======
        overScrollMode="never"
>>>>>>> a622a84fa9b65a4b43e8645addefe35ee1624fe7
        scrollEnabled={this.props.swipeEnabled}
        automaticallyAdjustContentInsets={false}
        bounces={false}
        alwaysBounceHorizontal={false}
        scrollsToTop={false}
        showsHorizontalScrollIndicator={false}
<<<<<<< HEAD
        scrollEventThrottle={16}
=======
        scrollEventThrottle={1}
>>>>>>> a622a84fa9b65a4b43e8645addefe35ee1624fe7
        onScroll={this._handleScroll}
        onMomentumScrollEnd={this._handleMomentumScrollEnd}
        contentOffset={this.state.initialOffset}
        style={styles.container}
        contentContainerStyle={layout.width ? null : styles.container}
<<<<<<< HEAD
        ref={this._setRef}
      >
        {Children.map(children, (child, i) =>
=======
        ref={el => (this._scrollView = el)}
      >
        {React.Children.map(children, (child, i) => (
>>>>>>> a622a84fa9b65a4b43e8645addefe35ee1624fe7
          <View
            key={navigationState.routes[i].key}
            testID={navigationState.routes[i].testID}
            style={
              layout.width
                ? { width: layout.width, overflow: 'hidden' }
                : i === navigationState.index ? styles.page : null
            }
          >
            {i === navigationState.index || layout.width ? child : null}
          </View>
<<<<<<< HEAD
        )}
=======
        ))}
>>>>>>> a622a84fa9b65a4b43e8645addefe35ee1624fe7
      </ScrollView>
    );
  }
}

const styles = StyleSheet.create({
  container: {
<<<<<<< HEAD
    flexGrow: 1,
  },

=======
    flex: 1,
  },
>>>>>>> a622a84fa9b65a4b43e8645addefe35ee1624fe7
  page: {
    flex: 1,
    overflow: 'hidden',
  },
});
