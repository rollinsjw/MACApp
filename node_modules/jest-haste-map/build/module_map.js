<<<<<<< HEAD
'use strict';Object.defineProperty(exports, "__esModule", { value: true });var _constants;
=======
'use strict';
>>>>>>> a622a84fa9b65a4b43e8645addefe35ee1624fe7
















<<<<<<< HEAD
function _load_constants() {return _constants = _interopRequireDefault(require('./constants'));}function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}
=======

var _constants = require('./constants');var _constants2 = _interopRequireDefault(_constants);function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}
>>>>>>> a622a84fa9b65a4b43e8645addefe35ee1624fe7

const EMPTY_MAP = {}; /**
                       * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
                       *
<<<<<<< HEAD
                       * This source code is licensed under the MIT license found in the
                       * LICENSE file in the root directory of this source tree.
                       *
                       * 
                       */class ModuleMap {constructor(raw) {this._raw = raw;
  }
=======
                       * This source code is licensed under the BSD-style license found in the
                       * LICENSE file in the root directory of this source tree. An additional grant
                       * of patent rights can be found in the PATENTS file in the same directory.
                       *
                       * 
                       */class ModuleMap {constructor(raw) {this._raw = raw;}
>>>>>>> a622a84fa9b65a4b43e8645addefe35ee1624fe7

  getModule(
  name,
  platform,
  supportsNativePlatform,
  type)
  {
    if (!type) {
<<<<<<< HEAD
      type = (_constants || _load_constants()).default.MODULE;
=======
      type = _constants2.default.MODULE;
>>>>>>> a622a84fa9b65a4b43e8645addefe35ee1624fe7
    }
    const module = this._getModuleMetadata(
    name,
    platform,
    !!supportsNativePlatform);

<<<<<<< HEAD
    if (module && module[(_constants || _load_constants()).default.TYPE] === type) {
      return module[(_constants || _load_constants()).default.PATH];
=======
    if (module && module[_constants2.default.TYPE] === type) {
      return module[_constants2.default.PATH];
>>>>>>> a622a84fa9b65a4b43e8645addefe35ee1624fe7
    }
    return null;
  }

  getPackage(
  name,
  platform,
  supportsNativePlatform)
  {
<<<<<<< HEAD
    return this.getModule(name, platform, null, (_constants || _load_constants()).default.PACKAGE);
=======
    return this.getModule(name, platform, null, _constants2.default.PACKAGE);
>>>>>>> a622a84fa9b65a4b43e8645addefe35ee1624fe7
  }

  getMockModule(name) {
    return this._raw.mocks[name];
  }

  getRawModuleMap() {
    return {
      duplicates: this._raw.duplicates,
      map: this._raw.map,
      mocks: this._raw.mocks };

  }

  /**
     * When looking up a module's data, we walk through each eligible platform for
     * the query. For each platform, we want to check if there are known
     * duplicates for that name+platform pair. The duplication logic normally
     * removes elements from the `map` object, but we want to check upfront to be
     * extra sure. If metadata exists both in the `duplicates` object and the
     * `map`, this would be a bug.
     */
  _getModuleMetadata(
  name,
  platform,
  supportsNativePlatform)
  {
    const map = this._raw.map[name] || EMPTY_MAP;
    const dupMap = this._raw.duplicates[name] || EMPTY_MAP;
    if (platform != null) {
      this._assertNoDuplicates(
      name,
      platform,
      supportsNativePlatform,
      dupMap[platform]);

      if (map[platform] != null) {
        return map[platform];
      }
    }
    if (supportsNativePlatform) {
      this._assertNoDuplicates(
      name,
<<<<<<< HEAD
      (_constants || _load_constants()).default.NATIVE_PLATFORM,
      supportsNativePlatform,
      dupMap[(_constants || _load_constants()).default.NATIVE_PLATFORM]);

      if (map[(_constants || _load_constants()).default.NATIVE_PLATFORM]) {
        return map[(_constants || _load_constants()).default.NATIVE_PLATFORM];
=======
      _constants2.default.NATIVE_PLATFORM,
      supportsNativePlatform,
      dupMap[_constants2.default.NATIVE_PLATFORM]);

      if (map[_constants2.default.NATIVE_PLATFORM]) {
        return map[_constants2.default.NATIVE_PLATFORM];
>>>>>>> a622a84fa9b65a4b43e8645addefe35ee1624fe7
      }
    }
    this._assertNoDuplicates(
    name,
<<<<<<< HEAD
    (_constants || _load_constants()).default.GENERIC_PLATFORM,
    supportsNativePlatform,
    dupMap[(_constants || _load_constants()).default.GENERIC_PLATFORM]);

    if (map[(_constants || _load_constants()).default.GENERIC_PLATFORM]) {
      return map[(_constants || _load_constants()).default.GENERIC_PLATFORM];
=======
    _constants2.default.GENERIC_PLATFORM,
    supportsNativePlatform,
    dupMap[_constants2.default.GENERIC_PLATFORM]);

    if (map[_constants2.default.GENERIC_PLATFORM]) {
      return map[_constants2.default.GENERIC_PLATFORM];
>>>>>>> a622a84fa9b65a4b43e8645addefe35ee1624fe7
    }
    return null;
  }

  _assertNoDuplicates(
  name,
  platform,
  supportsNativePlatform,
  set)
  {
    if (set == null) {
      return;
    }
    throw new DuplicateHasteCandidatesError(
    name,
    platform,
    supportsNativePlatform,
    set);

<<<<<<< HEAD
  }}exports.default = ModuleMap;
=======
  }}
>>>>>>> a622a84fa9b65a4b43e8645addefe35ee1624fe7


class DuplicateHasteCandidatesError extends Error {





  constructor(
  name,
  platform,
  supportsNativePlatform,
  duplicatesSet)
  {
    const platformMessage = getPlatformMessage(platform);
    super(
    `The name \`${name}\` was looked up in the Haste module map. It ` +
    `cannot be resolved, because there exists several different ` +
    `files, or packages, that provide a module for ` +
    `that particular name and platform. ${platformMessage} You must ` +
    `delete or blacklist files until there remains only one of these:\n\n` +
    Object.keys(duplicatesSet).
    sort().
    map(dupFilePath => {
      const typeMessage = getTypeMessage(duplicatesSet[dupFilePath]);
      return `  * \`${dupFilePath}\` (${typeMessage})\n`;
    }).
    join(''));

    this.hasteName = name;
    this.platform = platform;
    this.supportsNativePlatform = supportsNativePlatform;
    this.duplicatesSet = duplicatesSet;
  }}


function getPlatformMessage(platform) {
<<<<<<< HEAD
  if (platform === (_constants || _load_constants()).default.GENERIC_PLATFORM) {
=======
  if (platform === _constants2.default.GENERIC_PLATFORM) {
>>>>>>> a622a84fa9b65a4b43e8645addefe35ee1624fe7
    return 'The platform is generic (no extension).';
  }
  return `The platform extension is \`${platform}\`.`;
}

function getTypeMessage(type) {
  switch (type) {
<<<<<<< HEAD
    case (_constants || _load_constants()).default.MODULE:
      return 'module';
    case (_constants || _load_constants()).default.PACKAGE:
=======
    case _constants2.default.MODULE:
      return 'module';
    case _constants2.default.PACKAGE:
>>>>>>> a622a84fa9b65a4b43e8645addefe35ee1624fe7
      return 'package';}

  return 'unknown';
}

<<<<<<< HEAD
ModuleMap.DuplicateHasteCandidatesError = DuplicateHasteCandidatesError;
=======
ModuleMap.DuplicateHasteCandidatesError = DuplicateHasteCandidatesError;
module.exports = ModuleMap;
>>>>>>> a622a84fa9b65a4b43e8645addefe35ee1624fe7
